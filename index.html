<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Conway's Game of Life</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: #0f0f1a;
      color: #dde;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 24px;
      gap: 16px;
    }

    h1 {
      font-size: 17px;
      letter-spacing: 4px;
      text-transform: uppercase;
      color: #7ab8f5;
    }

    .app {
      display: flex;
      gap: 18px;
      align-items: flex-start;
    }

    canvas {
      border: 1px solid #2a2a4a;
      border-radius: 4px;
      cursor: crosshair;
      display: block;
      flex-shrink: 0;
    }

    /* ── right panel ── */
    .panel {
      width: 190px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .card {
      background: #161630;
      border: 1px solid #252550;
      border-radius: 8px;
      padding: 12px 14px;
    }

    .card-title {
      font-size: 9px;
      letter-spacing: 2px;
      text-transform: uppercase;
      color: #445;
      margin-bottom: 10px;
    }

    /* stats */
    .stat-row {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      font-size: 13px;
      color: #99a;
      margin-bottom: 5px;
    }
    .stat-row:last-child { margin-bottom: 0; }
    .stat-val { color: #7ecfff; font-weight: 700; font-size: 15px; }

    /* buttons */
    .btn-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px;
    }

    button {
      padding: 7px 6px;
      font-size: 12px;
      font-family: inherit;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-weight: 600;
      letter-spacing: 0.5px;
      transition: opacity 0.12s, transform 0.08s;
    }
    button:active:not(:disabled) { transform: scale(0.95); }
    button:hover:not(:disabled)  { opacity: 0.82; }
    button:disabled { opacity: 0.28; cursor: default; }

    #btnStep   { background: #3b82f6; color: #fff; }
    #btnClear  { background: #6b7280; color: #fff; }
    #btnRun    { background: #22c55e; color: #fff; }
    #btnStop   { background: #ef4444; color: #fff; }
    #btnRandom { background: #a855f7; color: #fff; grid-column: span 2; }

    /* speed slider */
    .slider-wrap {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    input[type=range] {
      flex: 1;
      accent-color: #3b82f6;
      cursor: pointer;
      height: 4px;
    }
    .speed-label {
      min-width: 38px;
      text-align: right;
      font-size: 12px;
      color: #7ecfff;
      font-weight: 700;
    }

    /* legend */
    .legend-grid {
      display: grid;
      grid-template-columns: repeat(9, 1fr);
      gap: 3px;
    }
    .legend-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
    }
    .lc {
      width: 100%;
      aspect-ratio: 1;
      border-radius: 2px;
      border: 1px solid #333;
    }
    .ln { font-size: 8px; color: #556; }

    /* hint */
    .hint { font-size: 10px; color: #334; }

    /* Modal Styling */
    .modal-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.75);
      backdrop-filter: blur(4px);
      display: none; /* Hidden by default */
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    .modal-overlay.active { display: flex; }

    .modal-content {
      background: #1a1a2e;
      border: 1px solid #2a2a4a;
      border-radius: 12px;
      width: 90%;
      max-width: 500px;
      padding: 30px;
      position: relative;
      color: #dde;
      box-shadow: 0 10px 40px rgba(0,0,0,0.6);
    }

    .modal-content h2 { margin-bottom: 20px; color: #7ab8f5; border-bottom: 1px solid #2a2a4a; padding-bottom: 10px; }
    .modal-content h3 { margin: 15px 0 10px 0; font-size: 16px; color: #7ecfff; }
    .modal-content p { font-size: 14px; line-height: 1.6; margin-bottom: 12px; color: #99a; }
    .modal-content ul { font-size: 14px; margin-left: 20px; color: #99a; }
    .modal-content li { margin-bottom: 5px; }

    .modal-close {
      position: absolute;
      top: 15px; right: 15px;
      background: none; border: none;
      color: #556; font-size: 24px;
      cursor: pointer;
    }
    .modal-close:hover { color: #dde; }

    .conway-portrait {
      position: fixed;
      bottom: -30px;
      right: -30px;
      width: 45vh;
      height: 45vh;
      object-fit: cover;
      object-position: center 15%;
      opacity: 0.35;
      z-index: -1;
      filter: sepia(100%) hue-rotate(15deg) saturate(400%) contrast(1.3) brightness(1.1);
      pointer-events: none;
      border-radius: 15px;
    }
  </style>
</head>
<body>

<h1 id="appTitle">Conway's Game of Life</h1>

<div class="app">
  <canvas id="canvas"></canvas>

  <div class="panel">

    <div class="card">
      <div class="card-title">Status</div>
      <div class="stat-row">
        <span>Lebende Zellen</span>
        <span class="stat-val" id="cellCount">0</span>
      </div>
      <div class="stat-row">
        <span>Generationen</span>
        <span class="stat-val" id="genCount">0</span>
      </div>
    </div>

    <div class="card">
      <div class="card-title">Steuerung</div>
      <div class="btn-grid">
        <button id="btnStep">Step</button>
        <button id="btnClear">Clear</button>
        <button id="btnRun">Run</button>
        <button id="btnStop" disabled>Stop</button>
        <button id="btnRandom">Zufällig</button>
      </div>
    </div>

    <div class="card">
      <div class="card-title">Geschwindigkeit</div>
      <div class="slider-wrap">
        <input type="range" id="speedSlider" min="1" max="240" value="8">
        <span class="speed-label"><span id="speedVal">8</span>/s</span>
      </div>
    </div>

    <div class="card">
      <div class="card-title">Nachbarn</div>
      <div class="legend-grid" id="legendGrid"></div>
    </div>

    <div class="card">
      <button id="btnInfo" style="width: 100%; background: #445; color: #fff;">Spielregeln</button>
    </div>

  </div>
</div>

<div class="hint">Klicken &amp; ziehen zum Setzen / Löschen</div>

<!-- Modal -->
<div id="infoModal" class="modal-overlay">
  <div class="modal-content">
    <button id="btnCloseModal" class="modal-close">&times;</button>
    <h2>Conway's Spiel des Lebens</h2>
    <div class="modal-body">
      <p>Das "Game of Life" ist ein 1970 von dem britischen Mathematiker <strong>John Horton Conway</strong> entworfenes System zur Simulation biologischer Evolution. Es ist ein "Null-Personen-Spiel", dessen Verlauf durch seinen Anfangszustand bestimmt wird.</p>
      
      <h3>Die Regeln</h3>
      <p>In jeder Generation wird der Zustand jeder Zelle basierend auf ihren 8 Nachbarn berechnet:</p>
      <ul>
        <li><strong>Einsamkeit:</strong> Eine lebende Zelle mit &lt; 2 Nachbarn stirbt.</li>
        <li><strong>Überleben:</strong> Eine lebende Zelle mit 2 oder 3 Nachbarn lebt weiter.</li>
        <li><strong>Überbevölkerung:</strong> Eine lebende Zelle mit &gt; 3 Nachbarn stirbt.</li>
        <li><strong>Reproduktion:</strong> Eine tote Zelle mit genau 3 Nachbarn wird lebendig.</li>
      </ul>

      <h3>Interaktion</h3>
      <p>Nutzen Sie die Maus, um Zellen auf dem Gitter zu aktivieren oder zu deaktivieren. Mit dem Geschwindigkeitsregler können Sie die Simulationsrate (Generationen pro Sekunde) anpassen.</p>
      
      <p style="font-size: 0.9em; margin-top: 1.5em; color: #778;"><em>John Horton Conway (1937–2020)</em></p>
    </div>
  </div>
</div>

<img src="portrait.jpeg" class="conway-portrait" alt="John Conway Portrait">

<script>
  const COLS = 100;
  const ROWS = 60;
  const CELL = 12;

  const NEIGHBOR_COLORS = [
    '#cfd8dc', '#80deea', '#4db6ac', '#81c784',
    '#fff176', '#ffb74d', '#ff8a65', '#e57373', '#d32f2f',
  ];
  const DEAD_COLOR = '#0d1117';

  // ── canvas ────────────────────────────────────────────────────────────────────
  const canvas = document.getElementById('canvas');
  const ctx    = canvas.getContext('2d');
  const W = COLS * CELL + 1;
  const H = ROWS * CELL + 1;
  canvas.width  = W;
  canvas.height = H;

  // Pre-render grid lines once onto an offscreen canvas
  const gridOff = Object.assign(document.createElement('canvas'), { width: W, height: H });
  const gCtx    = gridOff.getContext('2d');
  gCtx.strokeStyle = 'rgba(255,255,255,0.28)';
  gCtx.lineWidth   = 0.5;
  gCtx.beginPath();
  for (let c = 0; c <= COLS; c++) { gCtx.moveTo(c*CELL+0.5, 0); gCtx.lineTo(c*CELL+0.5, H); }
  for (let r = 0; r <= ROWS; r++) { gCtx.moveTo(0, r*CELL+0.5); gCtx.lineTo(W, r*CELL+0.5); }
  gCtx.stroke();

  // ── state ─────────────────────────────────────────────────────────────────────
  // Use Uint32Array for WebGPU compatibility (u32 alignment)
  // Flat array: index = y * COLS + x
  let grid       = new Uint32Array(ROWS * COLS);
  let generation = 0;
  let running    = false;
  let animId     = null;
  let lastTime   = 0;
  let stepsPerSec = 8;

  // WebGPU state
  let device, computePipeline, bindGroup0, bindGroup1;
  let buffer0, buffer1, stagingBuffer; // Ping-pong buffers + staging
  let usingWebGPU = false;
  let bufferState = 0; // 0: buffer0 is current, 1: buffer1 is current

  // ── webgpu init ───────────────────────────────────────────────────────────────
  const SHADER_CODE = `
    struct Params {
      width  : u32,
      height : u32,
    };

    @group(0) @binding(0) var<uniform> params : Params;
    @group(0) @binding(1) var<storage, read> input  : array<u32>;
    @group(0) @binding(2) var<storage, read_write> output : array<u32>;

    fn get_idx(x: u32, y: u32) -> u32 {
      return y * params.width + x;
    }

    @compute @workgroup_size(8, 8)
    fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {
      let x = global_id.x;
      let y = global_id.y;

      if (x >= params.width || y >= params.height) {
        return;
      }

      let idx = get_idx(x, y);
      let current = input[idx];

      var neighbors = 0u;
      for (var dy = -1; dy <= 1; dy++) {
        for (var dx = -1; dx <= 1; dx++) {
          if (dx == 0 && dy == 0) { continue; }
          
          let nx = i32(x) + dx;
          let ny = i32(y) + dy;

          if (nx >= 0 && nx < i32(params.width) && ny >= 0 && ny < i32(params.height)) {
             neighbors += input[get_idx(u32(nx), u32(ny))];
          }
        }
      }

      var next_state = 0u;
      if (current == 1u) {
        if (neighbors == 2u || neighbors == 3u) { next_state = 1u; }
      } else {
        if (neighbors == 3u) { next_state = 1u; }
      }
      
      output[idx] = next_state;
    }
  `;

  async function initWebGPU() {
    if (!navigator.gpu) {
      console.log("WebGPU not supported, falling back to CPU.");
      return;
    }

    try {
      const adapter = await navigator.gpu.requestAdapter();
      if (!adapter) throw new Error("No adapter");
      device = await adapter.requestDevice();

      // Create buffers
      const gridSize = ROWS * COLS * 4; // u32 = 4 bytes
      buffer0 = device.createBuffer({ size: gridSize, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
      buffer1 = device.createBuffer({ size: gridSize, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
      
      // Reusable staging buffer for reading back data
      stagingBuffer = device.createBuffer({
        size: gridSize,
        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
      });

      const paramBuf = device.createBuffer({ size: 8, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
      device.queue.writeBuffer(paramBuf, 0, new Uint32Array([COLS, ROWS]));

      // Pipeline
      const module = device.createShaderModule({ code: SHADER_CODE });
      computePipeline = device.createComputePipeline({
        layout: 'auto',
        compute: { module, entryPoint: 'main' }
      });

      // Bind Groups (Ping-Pong)
      // Group 0: Read buffer0, Write buffer1
      bindGroup0 = device.createBindGroup({
        layout: computePipeline.getBindGroupLayout(0),
        entries: [
          { binding: 0, resource: { buffer: paramBuf } },
          { binding: 1, resource: { buffer: buffer0 } },
          { binding: 2, resource: { buffer: buffer1 } }
        ]
      });

      // Group 1: Read buffer1, Write buffer0
      bindGroup1 = device.createBindGroup({
        layout: computePipeline.getBindGroupLayout(0),
        entries: [
          { binding: 0, resource: { buffer: paramBuf } },
          { binding: 1, resource: { buffer: buffer1 } },
          { binding: 2, resource: { buffer: buffer0 } }
        ]
      });

      usingWebGPU = true;
      console.log("WebGPU initialized.");
      document.getElementById('appTitle').innerHTML = 'Conway\'s Game of Life <span style="font-size: 0.6em; color: #22c55e; vertical-align: middle; margin-left: 10px;">[GPU]</span>';
      
      // Initial upload
      device.queue.writeBuffer(buffer0, 0, grid);

    } catch (e) {
      console.error("WebGPU init failed:", e);
      usingWebGPU = false;
    }
  }

  initWebGPU();

  // ── logic ─────────────────────────────────────────────────────────────────────
  // CPU Fallback logic
  function nbCount(g, r, c) {
    let n = 0;
    for (let dr = -1; dr <= 1; dr++) {
      const nr = r + dr;
      if (nr < 0 || nr >= ROWS) continue;
      for (let dc = -1; dc <= 1; dc++) {
        if (dr === 0 && dc === 0) continue;
        const nc = c + dc;
        if (nc >= 0 && nc < COLS) {
          n += g[nr * COLS + nc];
        }
      }
    }
    return n;
  }

  function stepCPU() {
    const next = new Uint32Array(ROWS * COLS);
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        const idx = r * COLS + c;
        const n = nbCount(grid, r, c);
        const cell = grid[idx];
        next[idx] = cell ? (n === 2 || n === 3 ? 1 : 0) : (n === 3 ? 1 : 0);
      }
    }
    grid = next;
    generation++;
  }

  async function stepGPU() {
    // Current input buffer is bufferState (0 or 1)
    // We want to write to the other one.
    const bindGroup = bufferState === 0 ? bindGroup0 : bindGroup1;
    
    const commandEncoder = device.createCommandEncoder();
    const passEncoder = commandEncoder.beginComputePass();
    passEncoder.setPipeline(computePipeline);
    passEncoder.setBindGroup(0, bindGroup);
    // Workgroups: ceil(COLS/8), ceil(ROWS/8)
    passEncoder.dispatchWorkgroups(Math.ceil(COLS / 8), Math.ceil(ROWS / 8));
    passEncoder.end();

    // Copy result back to staging buffer to read
    // The result is in the *destination* buffer of the current pass.
    // If bufferState was 0 (Input=B0, Output=B1), result is in B1.
    const resultBuffer = bufferState === 0 ? buffer1 : buffer0;
    
    commandEncoder.copyBufferToBuffer(resultBuffer, 0, stagingBuffer, 0, grid.byteLength);

    device.queue.submit([commandEncoder.finish()]);

    await stagingBuffer.mapAsync(GPUMapMode.READ);
    const copyArrayBuffer = stagingBuffer.getMappedRange();
    grid.set(new Uint32Array(copyArrayBuffer));
    stagingBuffer.unmap();
    
    // Flip buffer state for next frame
    bufferState = 1 - bufferState;
    generation++;
  }

  async function step() {
    if (usingWebGPU) {
      await stepGPU();
    } else {
      stepCPU();
    }
  }

  // ── rendering ─────────────────────────────────────────────────────────────────
  function draw() {
    // background (dead cells)
    ctx.fillStyle = DEAD_COLOR;
    ctx.fillRect(0, 0, W, H);

    // alive cells only
    let alive = 0;
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        const idx = r * COLS + c;
        if (!grid[idx]) continue;
        alive++;
        
        // For color, we still need neighbor count. 
        // Note: CPU calculation for color is fast enough for rendering.
        const n = nbCount(grid, r, c);
        
        const x = c * CELL, y = r * CELL;
        ctx.fillStyle = NEIGHBOR_COLORS[n] || NEIGHBOR_COLORS[8];
        ctx.fillRect(x, y, CELL, CELL);
        ctx.strokeStyle = '#000';
        ctx.lineWidth   = 1.5;
        ctx.strokeRect(x + 0.75, y + 0.75, CELL - 1.5, CELL - 1.5);
      }
    }

    // composite pre-rendered grid lines
    ctx.drawImage(gridOff, 0, 0);

    document.getElementById('cellCount').textContent = alive;
    document.getElementById('genCount').textContent  = generation;
  }

  // ── run loop ──────────────────────────────────────────────────────────────────
  function loop(time) {
    if (!running) return;
    const interval = 1000 / stepsPerSec;
    if (time - lastTime >= interval) {
      // Async step needs handling
      // We process one step per frame-check to keep it simple with async GPU
      step().then(() => {
        draw();
        lastTime = time;
        animId = requestAnimationFrame(loop);
      });
    } else {
      animId = requestAnimationFrame(loop);
    }
  }

  // ── mouse ─────────────────────────────────────────────────────────────────────
  let painting = false, paintMode = 1;

  function cellAt(e) {
    return { r: Math.floor(e.offsetY / CELL), c: Math.floor(e.offsetX / CELL) };
  }

  function updateCell(r, c, val) {
    if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return;
    grid[r * COLS + c] = val;
    // If using GPU, we must update the current input buffer
    if (usingWebGPU) {
      const currentBuffer = bufferState === 0 ? buffer0 : buffer1;
      device.queue.writeBuffer(currentBuffer, (r * COLS + c) * 4, new Uint32Array([val]));
    }
  }

  canvas.addEventListener('mousedown', e => {
    const { r, c } = cellAt(e);
    const idx = r * COLS + c;
    if (idx >= 0 && idx < grid.length) {
      paintMode  = grid[idx] === 0 ? 1 : 0;
      painting   = true;
      updateCell(r, c, paintMode);
      draw();
    }
  });
  canvas.addEventListener('mousemove', e => {
    if (!painting) return;
    const { r, c } = cellAt(e);
    updateCell(r, c, paintMode);
    draw();
  });
  canvas.addEventListener('mouseup',    () => { painting = false; });
  canvas.addEventListener('mouseleave', () => { painting = false; });
  canvas.addEventListener('dragstart',  e => e.preventDefault());

  // ── buttons ───────────────────────────────────────────────────────────────────
  function setRunning(val) {
    running = val;
    document.getElementById('btnRun').disabled   = val;
    document.getElementById('btnStep').disabled  = val;
    document.getElementById('btnStop').disabled  = !val;
  }

  document.getElementById('btnStep').addEventListener('click', () => { 
    step().then(draw); 
  });

  document.getElementById('btnRun').addEventListener('click', () => {
    setRunning(true);
    lastTime = performance.now();
    loop(lastTime); // loop handles requestAnimationFrame
  });

  document.getElementById('btnStop').addEventListener('click', () => {
    setRunning(false);
    if (animId) cancelAnimationFrame(animId);
  });

  document.getElementById('btnClear').addEventListener('click', () => {
    setRunning(false);
    if (animId) cancelAnimationFrame(animId);
    grid.fill(0);
    generation = 0;
    // Sync to GPU
    if (usingWebGPU) {
      device.queue.writeBuffer(buffer0, 0, grid);
      device.queue.writeBuffer(buffer1, 0, grid);
      bufferState = 0;
    }
    draw();
  });

  document.getElementById('btnRandom').addEventListener('click', () => {
    for (let i = 0; i < grid.length; i++) {
        grid[i] = Math.random() < 0.3 ? 1 : 0;
    }
    // Sync to GPU
    if (usingWebGPU) {
      device.queue.writeBuffer(buffer0, 0, grid);
      device.queue.writeBuffer(buffer1, 0, grid);
      bufferState = 0;
    }
    draw();
  });

  // ── speed slider ──────────────────────────────────────────────────────────────
  const slider = document.getElementById('speedSlider');
  slider.addEventListener('input', () => {
    stepsPerSec = +slider.value;
    document.getElementById('speedVal').textContent = stepsPerSec;
  });

  // ── modal logic ───────────────────────────────────────────────────────────────
  const infoModal = document.getElementById('infoModal');
  const btnInfo   = document.getElementById('btnInfo');
  const btnClose  = document.getElementById('btnCloseModal');

  btnInfo.addEventListener('click', () => {
    infoModal.classList.add('active');
  });

  btnClose.addEventListener('click', () => {
    infoModal.classList.remove('active');
  });

  // close modal when clicking outside content
  infoModal.addEventListener('click', (e) => {
    if (e.target === infoModal) {
      infoModal.classList.remove('active');
    }
  });

  // ── legend ────────────────────────────────────────────────────────────────────
  const legendGrid = document.getElementById('legendGrid');
  NEIGHBOR_COLORS.forEach((color, i) => {
    const el = document.createElement('div');
    el.className = 'legend-item';
    el.innerHTML = `<div class="lc" style="background:${color}"></div><div class="ln">${i}</div>`;
    legendGrid.appendChild(el);
  });

  // ── init ──────────────────────────────────────────────────────────────────────
  draw();
</script>
</body>
</html>
