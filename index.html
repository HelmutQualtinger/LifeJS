<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Conway's Game of Life (WebGL)</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: #0f0f1a;
      color: #dde;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 24px;
      gap: 16px;
    }

    h1 {
      font-size: 17px;
      letter-spacing: 4px;
      text-transform: uppercase;
      color: #7ab8f5;
    }

    .app {
      display: flex;
      gap: 18px;
      align-items: flex-start;
    }

    canvas {
      border: 1px solid #2a2a4a;
      border-radius: 4px;
      cursor: crosshair;
      display: block;
      flex-shrink: 0;
    }

    /* ── right panel ── */
    .panel {
      width: 190px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .card {
      background: #161630;
      border: 1px solid #252550;
      border-radius: 8px;
      padding: 12px 14px;
    }

    .card-title {
      font-size: 9px;
      letter-spacing: 2px;
      text-transform: uppercase;
      color: #445;
      margin-bottom: 10px;
    }

    /* stats */
    .stat-row {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      font-size: 13px;
      color: #99a;
      margin-bottom: 5px;
    }
    .stat-row:last-child { margin-bottom: 0; }
    .stat-val { color: #7ecfff; font-weight: 700; font-size: 15px; }

    /* buttons */
    .btn-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px;
    }

    button {
      padding: 7px 6px;
      font-size: 12px;
      font-family: inherit;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-weight: 600;
      letter-spacing: 0.5px;
      transition: opacity 0.12s, transform 0.08s;
    }
    button:active:not(:disabled) { transform: scale(0.95); }
    button:hover:not(:disabled)  { opacity: 0.82; }
    button:disabled { opacity: 0.28; cursor: default; }

    #btnStep   { background: #3b82f6; color: #fff; }
    #btnClear  { background: #6b7280; color: #fff; }
    #btnRun    { background: #22c55e; color: #fff; }
    #btnStop   { background: #ef4444; color: #fff; }
    #btnRandom { background: #a855f7; color: #fff; }
    #btnGun    { background: #ec4899; color: #fff; }
    #btnHelp   { background: #f59e0b; color: #fff; }

    /* modal */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(5px);
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    .modal-content {
      background: #161630;
      border: 1px solid #252550;
      padding: 30px;
      border-radius: 12px;
      max-width: 500px;
      width: 100%;
      position: relative;
      color: #dde;
      line-height: 1.6;
      box-shadow: 0 20px 50px rgba(0,0,0,0.5);
    }
    .modal-content h2 { color: #7ab8f5; margin-bottom: 15px; font-size: 20px; }
    .modal-content h3 { color: #7ecfff; margin-top: 20px; margin-bottom: 10px; font-size: 16px; text-transform: uppercase; letter-spacing: 1px; }
    .modal-content ul { padding-left: 20px; margin-bottom: 15px; }
    .modal-content li { margin-bottom: 8px; font-size: 14px; }
    .close-btn {
      position: absolute;
      top: 15px;
      right: 20px;
      font-size: 28px;
      cursor: pointer;
      color: #445;
      line-height: 1;
    }
    .close-btn:hover { color: #fff; }
    .example-box {
      background: #1c1c3c;
      padding: 12px;
      border-radius: 6px;
      margin-bottom: 10px;
      font-size: 13px;
      border-left: 3px solid #7ab8f5;
      display: flex;
      align-items: center;
      gap: 15px;
    }
    .example-gfx {
      flex-shrink: 0;
      width: 44px;
      height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #0f0f1a;
      border-radius: 4px;
      padding: 4px;
    }
    .example-gfx svg {
      width: 100%;
      height: 100%;
      fill: #7ecfff;
    }

    /* speed slider */
    .slider-wrap {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    input[type=range] {
      flex: 1;
      accent-color: #3b82f6;
      cursor: pointer;
      height: 4px;
    }
    .speed-label {
      min-width: 38px;
      text-align: right;
      font-size: 12px;
      color: #7ecfff;
      font-weight: 700;
    }

    /* legend */
    .legend-grid {
      display: grid;
      grid-template-columns: repeat(9, 1fr);
      gap: 3px;
    }
    .legend-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
    }
    .lc {
      width: 100%;
      aspect-ratio: 1;
      border-radius: 2px;
      border: 1px solid #333;
    }
    .ln { font-size: 8px; color: #556; }

    /* hint */
    .hint { font-size: 10px; color: #334; }

    /* portrait */
    .portrait {
      position: fixed;
      bottom: 16px;
      right: 16px;
      width: 160px;
      height: 160px;
      object-fit: cover;
      border-radius: 50%;
      border: 2px solid #2a2a4a;
      filter: url(#solarize);
    }
  </style>
</head>
<body>

<h1>Conway's Game of Life (WebGL)</h1>

<div class="app">
  <canvas id="canvas"></canvas>

  <div class="panel">

    <div class="card">
      <div class="card-title">Status</div>
      <div class="stat-row">
        <span>Lebende Zellen</span>
        <span class="stat-val" id="cellCount">0</span>
      </div>
      <div class="stat-row">
        <span>Generationen</span>
        <span class="stat-val" id="genCount">0</span>
      </div>
    </div>

    <div class="card">
      <div class="card-title">Steuerung</div>
      <div class="btn-grid">
        <button id="btnStep">Step</button>
        <button id="btnClear">Clear</button>
        <button id="btnRun">Run</button>
        <button id="btnStop" disabled>Stop</button>
        <button id="btnRandom">Zufällig</button>
        <button id="btnGun">Glider Gun</button>
        <button id="btnHelp">Hilfe</button>
      </div>
    </div>

    <div class="card">
      <div class="card-title">Geschwindigkeit</div>
      <div class="slider-wrap">
        <input type="range" id="speedSlider" min="1" max="480" value="8">
        <span class="speed-label"><span id="speedVal">8</span>/s</span>
      </div>
    </div>

    <div class="card">
      <div class="card-title">Nachbarn</div>
      <div class="legend-grid" id="legendGrid"></div>
    </div>

  </div>
</div>

<div class="hint">Klicken &amp; ziehen zum Setzen / Löschen</div>

<svg width="0" height="0" style="position:absolute">
  <defs>
    <filter id="solarize">
      <feComponentTransfer>
        <feFuncR type="table" tableValues="0 0.2 0.4 0.6 0.8 1 0.8 0.6 0.4 0.2 0"/>
        <feFuncG type="table" tableValues="0 0.2 0.4 0.6 0.8 1 0.8 0.6 0.4 0.2 0"/>
        <feFuncB type="table" tableValues="0 0.2 0.4 0.6 0.8 1 0.8 0.6 0.4 0.2 0"/>
      </feComponentTransfer>
    </filter>
  </defs>
</svg>

<div id="helpModal" class="modal">
  <div class="modal-content">
    <span class="close-btn" id="closeHelp">&times;</span>
    <h2>Game of Life</h2>
    <p>Das "Spiel des Lebens" ist ein zellulärer Automat von John Conway. Es ist ein "Null-Spieler-Spiel", das sich nach festen Regeln von selbst entwickelt.</p>
    
    <h3>Die Regeln:</h3>
    <ul>
      <li><strong>Überleben:</strong> Jede lebende Zelle mit 2 oder 3 lebenden Nachbarn bleibt am Leben.</li>
      <li><strong>Tod:</strong> Jede lebende Zelle mit <2 (Einsamkeit) oder >3 (Überbevölkerung) Nachbarn stirbt.</li>
      <li><strong>Geburt:</strong> Jede tote Zelle mit genau 3 lebenden Nachbarn wird lebendig.</li>
    </ul>

    <h3>Interessante Muster:</h3>
    <div class="example-box">
      <div class="example-gfx"><svg viewBox="0 0 3 3"><rect x="1" y="0" width="0.9" height="0.9" rx="0.1"/><rect x="2" y="1" width="0.9" height="0.9" rx="0.1"/><rect x="0" y="2" width="0.9" height="0.9" rx="0.1"/><rect x="1" y="2" width="0.9" height="0.9" rx="0.1"/><rect x="2" y="2" width="0.9" height="0.9" rx="0.1"/></svg></div>
      <span><strong>Gleiter (Glider):</strong> Ein kleines Muster, das über das Feld wandert.</span>
    </div>
    <div class="example-box">
      <div class="example-gfx"><svg viewBox="0 0 3 3"><rect x="1" y="0" width="0.9" height="0.9" rx="0.1"/><rect x="1" y="1" width="0.9" height="0.9" rx="0.1"/><rect x="1" y="2" width="0.9" height="0.9" rx="0.1"/></svg></div>
      <span><strong>Oszillatoren:</strong> Muster wie der "Blinker", die zwischen Zuständen hin- und herwechseln.</span>
    </div>
    <div class="example-box">
      <div class="example-gfx"><svg viewBox="0 0 4 4"><rect x="1" y="1" width="0.9" height="0.9" rx="0.1"/><rect x="2" y="1" width="0.9" height="0.9" rx="0.1"/><rect x="1" y="2" width="0.9" height="0.9" rx="0.1"/><rect x="2" y="2" width="0.9" height="0.9" rx="0.1"/></svg></div>
      <span><strong>Still-Lifes:</strong> Stabile Muster wie der "Block", die sich nie verändern.</span>
    </div>
  </div>
</div>

<img src="portrait.jpeg" alt="Portrait" class="portrait">

<script>
  const COLS = 100;
  const ROWS = 60;
  const CELL = 12;

  const NEIGHBOR_COLORS = [
    '#cfd8dc', '#80deea', '#4db6ac', '#81c784',
    '#fff176', '#ffb74d', '#ff8a65', '#e57373', '#d32f2f',
  ];

  const canvas = document.getElementById('canvas');
  const W = COLS * CELL + 1;
  const H = ROWS * CELL + 1;
  canvas.width  = W;
  canvas.height = H;

  const gl = canvas.getContext('webgl2');
  if (!gl) alert('WebGL2 nicht verfügbar');

  // ── shaders ───────────────────────────────────────────────────────────────────
  function compileShader(type, src) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS))
      throw new Error(gl.getShaderInfoLog(s));
    return s;
  }

  function createProgram(vsSrc, fsSrc) {
    const p = gl.createProgram();
    gl.attachShader(p, compileShader(gl.VERTEX_SHADER, vsSrc));
    gl.attachShader(p, compileShader(gl.FRAGMENT_SHADER, fsSrc));
    gl.linkProgram(p);
    if (!gl.getProgramParameter(p, gl.LINK_STATUS))
      throw new Error(gl.getProgramInfoLog(p));
    return p;
  }

  const VS = `#version 300 es
in vec2 a_pos;
void main() { gl_Position = vec4(a_pos, 0.0, 1.0); }`;

  const simFS = `#version 300 es
precision mediump float;
uniform sampler2D u_cells;
out vec4 fragColor;
const ivec2 SIZE = ivec2(${COLS}, ${ROWS});
void main() {
  ivec2 fc = ivec2(gl_FragCoord.xy);
  int n = 0;
  for(int dy = -1; dy <= 1; dy++) {
    for(int dx = -1; dx <= 1; dx++) {
      if(dx == 0 && dy == 0) continue;
      ivec2 nb = fc + ivec2(dx, dy);
      if(nb.x >= 0 && nb.x < SIZE.x && nb.y >= 0 && nb.y < SIZE.y) {
        if(texelFetch(u_cells, nb, 0).r > 0.5) n++;
      }
    }
  }
  bool alive = texelFetch(u_cells, fc, 0).r > 0.5;
  bool next  = alive ? (n == 2 || n == 3) : (n == 3);
  fragColor  = vec4(next ? 1.0 : 0.0, 0.0, 0.0, 1.0);
}`;

  const renderFS = `#version 300 es
precision mediump float;
uniform sampler2D u_cells;
out vec4 fragColor;
const int   COLS   = ${COLS};
const int   ROWS   = ${ROWS};
const float CELL_F = ${CELL}.0;
const float H_F    = ${H}.0;
void main() {
  float px = gl_FragCoord.x;
  float py = H_F - gl_FragCoord.y;
  int col = clamp(int(px / CELL_F), 0, COLS - 1);
  int row = clamp(int(py / CELL_F), 0, ROWS - 1);
  ivec2 gridPos = ivec2(col, row);
  float sx = mod(px, CELL_F);
  float sy = mod(py, CELL_F);
  bool alive = texelFetch(u_cells, gridPos, 0).r > 0.5;
  int n = 0;
  for(int dy = -1; dy <= 1; dy++) {
    for(int dx = -1; dx <= 1; dx++) {
      if(dx == 0 && dy == 0) continue;
      ivec2 nb = gridPos + ivec2(dx, dy);
      if(nb.x >= 0 && nb.x < COLS && nb.y >= 0 && nb.y < ROWS) {
        if(texelFetch(u_cells, nb, 0).r > 0.5) n++;
      }
    }
  }
  vec3 nc[9];
  nc[0]=vec3(0.812,0.847,0.863); nc[1]=vec3(0.502,0.871,0.918); nc[2]=vec3(0.302,0.714,0.675);
  nc[3]=vec3(0.506,0.780,0.518); nc[4]=vec3(1.000,0.945,0.463); nc[5]=vec3(1.000,0.718,0.302);
  nc[6]=vec3(1.000,0.541,0.396); nc[7]=vec3(0.898,0.451,0.451); nc[8]=vec3(0.827,0.184,0.184);
  vec3 dead = vec3(0.051, 0.067, 0.090);
  vec3 color = dead;
  if (alive) {
    bool border = sx < 2.0 || sx > CELL_F - 2.0 || sy < 2.0 || sy > CELL_F - 2.0;
    color = border ? vec3(0.0) : nc[n];
  }
  if (sx < 1.0 || sy < 1.0) color = mix(color, vec3(1.0), 0.28);
  fragColor = vec4(color, 1.0);
}`;

  const simProg    = createProgram(VS, simFS);
  const renderProg = createProgram(VS, renderFS);

  // ── quad ──────────────────────────────────────────────────────────────────────
  const vao = gl.createVertexArray();
  gl.bindVertexArray(vao);
  const vbuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vbuf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);
  const aPosLoc = gl.getAttribLocation(renderProg, 'a_pos');
  gl.enableVertexAttribArray(aPosLoc);
  gl.vertexAttribPointer(aPosLoc, 2, gl.FLOAT, false, 0, 0);

  // ── textures & fbos ───────────────────────────────────────────────────────────
  function createTexture() {
    const t = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, t);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, COLS, ROWS, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    return t;
  }
  function createFBO(tex) {
    const fbo = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
    return fbo;
  }

  let tex0 = createTexture(), tex1 = createTexture();
  let fbo0 = createFBO(tex0), fbo1 = createFBO(tex1);
  let currentTex = tex0, nextFBO = fbo1, nextTex = tex1;

  function swap() {
    [currentTex, nextTex] = [nextTex, currentTex];
    nextFBO = (currentTex === tex0) ? fbo1 : fbo0;
  }

  // ── state ─────────────────────────────────────────────────────────────────────
  let generation = 0, running = false, animId = null, lastTime = 0, stepsPerSec = 8;
  const texData = new Uint8Array(COLS * ROWS * 4);

  function uploadGrid(grid) {
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        const idx = (r * COLS + c) * 4;
        texData[idx] = grid[r][c] ? 255 : 0;
        texData[idx+1] = 0;
        texData[idx+2] = 0;
        texData[idx+3] = 255;
      }
    }
    gl.bindTexture(gl.TEXTURE_2D, currentTex);
    gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, COLS, ROWS, gl.RGBA, gl.UNSIGNED_BYTE, texData);
  }

  function downloadGrid() {
    const fbo = (currentTex === tex0) ? fbo0 : fbo1;
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    gl.readPixels(0, 0, COLS, ROWS, gl.RGBA, gl.UNSIGNED_BYTE, texData);
    let alive = 0;
    const grid = Array.from({ length: ROWS }, () => new Uint8Array(COLS));
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (texData[(r * COLS + c) * 4] > 128) { grid[r][c] = 1; alive++; }
      }
    }
    return { grid, alive };
  }

  function step() {
    gl.useProgram(simProg);
    gl.bindFramebuffer(gl.FRAMEBUFFER, nextFBO);
    gl.viewport(0, 0, COLS, ROWS);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, currentTex);
    gl.uniform1i(gl.getUniformLocation(simProg, 'u_cells'), 0);
    gl.bindVertexArray(vao);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    swap();
    generation++;
  }

  function draw() {
    gl.useProgram(renderProg);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0, 0, W, H);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, currentTex);
    gl.uniform1i(gl.getUniformLocation(renderProg, 'u_cells'), 0);
    gl.bindVertexArray(vao);
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    const { alive } = downloadGrid();
    document.getElementById('cellCount').textContent = alive;
    document.getElementById('genCount').textContent  = generation;
  }

  function loop(time) {
    if (!running) return;
    const interval = 1000 / stepsPerSec;
    if (time - lastTime >= interval) {
      const burst = Math.min(Math.floor((time - lastTime) / interval), 4);
      for (let i = 0; i < burst; i++) step();
      draw();
      lastTime = time;
    }
    animId = requestAnimationFrame(loop);
  }

  // ── mouse ─────────────────────────────────────────────────────────────────────
  let painting = false, paintMode = 1;
  canvas.addEventListener('mousedown', e => {
    const { grid } = downloadGrid();
    const r = Math.floor(e.offsetY / CELL), c = Math.floor(e.offsetX / CELL);
    if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return;
    paintMode = grid[r][c] === 0 ? 1 : 0;
    painting = true;
    grid[r][c] = paintMode;
    uploadGrid(grid);
    draw();
  });
  canvas.addEventListener('mousemove', e => {
    if (!painting) return;
    const { grid } = downloadGrid();
    const r = Math.floor(e.offsetY / CELL), c = Math.floor(e.offsetX / CELL);
    if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return;
    grid[r][c] = paintMode;
    uploadGrid(grid);
    draw();
  });
  canvas.addEventListener('mouseup', () => painting = false);
  canvas.addEventListener('mouseleave', () => painting = false);
  canvas.addEventListener('dragstart', e => e.preventDefault());

  // ── buttons ───────────────────────────────────────────────────────────────────
  const setRunning = v => {
    running = v;
    document.getElementById('btnRun').disabled = v;
    document.getElementById('btnStep').disabled = v;
    document.getElementById('btnStop').disabled = !v;
  };
  document.getElementById('btnStep').onclick = () => { step(); draw(); };
  document.getElementById('btnRun').onclick = () => { setRunning(true); lastTime = performance.now(); animId = requestAnimationFrame(loop); };
  document.getElementById('btnStop').onclick = () => { setRunning(false); cancelAnimationFrame(animId); };
  document.getElementById('btnClear').onclick = () => {
    setRunning(false); cancelAnimationFrame(animId);
    uploadGrid(Array.from({ length: ROWS }, () => new Uint8Array(COLS)));
    generation = 0; draw();
  };
  document.getElementById('btnRandom').onclick = () => {
    const g = Array.from({ length: ROWS }, () => new Uint8Array(COLS));
    for(let r=0; r<ROWS; r++) for(let c=0; c<COLS; c++) g[r][c] = Math.random() < 0.3 ? 1 : 0;
    uploadGrid(g); draw();
  };
  document.getElementById('btnGun').onclick = () => {
    setRunning(false); cancelAnimationFrame(animId);
    const g = Array.from({ length: ROWS }, () => new Uint8Array(COLS));
    const gun = [
      [1, 5], [2, 5], [1, 6], [2, 6], [11, 5], [11, 6], [11, 7], [12, 4], [12, 8], [13, 3], [13, 9], [14, 3], [14, 9], [15, 6], [16, 4], [16, 8], [17, 5], [17, 6], [17, 7], [18, 6], [21, 3], [21, 4], [21, 5], [22, 3], [22, 4], [22, 5], [23, 2], [23, 6], [25, 1], [25, 2], [25, 6], [25, 7], [35, 3], [35, 4], [36, 3], [36, 4]
    ];
    // Kanone 1 (Oben links, schießt nach unten rechts)
    gun.forEach(([x, y]) => { if (y + 2 < ROWS && x + 2 < COLS) g[y + 2][x + 2] = 1; });
    // Kanone 2 (Leicht versetzt oben rechts, gespiegelt, schießt nach unten links)
    gun.forEach(([x, y]) => {
      const mx = (COLS - 1) - (x + 2);
      const my = y + 22; // Versatz um 20 Reihen nach unten (relativ zur 1. Kanone)
      if (my < ROWS && mx >= 0) g[my][mx] = 1;
    });
    generation = 0; uploadGrid(g); draw();
  };

  const helpModal = document.getElementById('helpModal');
  document.getElementById('btnHelp').onclick = () => helpModal.style.display = 'flex';
  document.getElementById('closeHelp').onclick = () => helpModal.style.display = 'none';
  window.onclick = e => { if (e.target === helpModal) helpModal.style.display = 'none'; };

  const slider = document.getElementById('speedSlider');
  slider.oninput = () => { stepsPerSec = +slider.value; document.getElementById('speedVal').textContent = stepsPerSec; };

  // ── legend ────────────────────────────────────────────────────────────────────
  const legendGrid = document.getElementById('legendGrid');
  NEIGHBOR_COLORS.forEach((color, i) => {
    const el = document.createElement('div');
    el.className = 'legend-item';
    el.innerHTML = `<div class="lc" style="background:${color}"></div><div class="ln">${i}</div>`;
    legendGrid.appendChild(el);
  });

  draw();
</script>
</body>
</html>
